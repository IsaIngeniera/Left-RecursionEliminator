# Left-RecursionEliminator

**This project was made by:**  
- Isabella Ocampo  
- Maria Laura Tafur  

**Group:** C2566 SI2002-5730  

For the implementation of this project, the operating system used was **Windows 10**, the programming language was **Java**, and the main development tool was **IntelliJ IDEA 2025.1**. These tools provided a stable environment for coding, testing, and running the program, ensuring compatibility and efficiency during the implementation process.

## Program Description

This **Java program** implements the **General Algorithm for Eliminating Left Recursion** from a *Context-Free Grammar (CFG)*.  

It uses standard Java libraries for:
- **Input handling:** `Scanner`
- **Collections management:** `Map`, `List`  

These are used to efficiently store and process grammar productions.

The program takes a **grammar as input** and produces an **equivalent grammar free of left recursion** — both **direct** and **indirect**.

---

## INSTRUCTIONS

## 1. Download and Structure

Make sure you have the following files located in the **same directory**:
- `GrammarManager.java`
- `LeftRecursionEliminator.java`

---

## 2. Compilation

Open your **terminal** or **command prompt** in the project directory and compile both files:


javac GrammarManager.java LeftRecursionEliminator.java


---

## EXPLANATION

This **Java program** implements the **General Algorithm for Eliminating Left Recursion** from a Context-Free Grammar ($G$). The goal is to transform a grammar into an equivalent one that is suitable for top-down parsing methods (e.g., Predictive Parsers).

The algorithm is based on processing the non-terminals  in the strict **order of appearance** in the input, resolving indirect recursion before tackling direct recursion.

### 1. Algorithm Overview 

The entire process is driven by iterating through the non-terminals and, for each one, applying two sequential steps: substitution and immediate elimination.

### 2. Iterative Substitution (Eliminating Indirect Left Recursion)

For each current **Non-Terminal (NT)** (let's call it **A**), the algorithm reviews the NTs that precede it in the processing order.  
This step converts *indirect recursion* into *direct recursion*:

**Rule:**  
If the NT **A** has a production that starts with a preceding Non-Terminal (let's call it **B**) — for example, if  
`A → B γ`  
(where **γ** is a chain of symbols), this indicates **indirect left recursion**.  
This production must be **substituted**.

**Action:**  
The production containing **B** is replaced by all of **B**’s alternatives.  
The NT **B** is substituted with all its productions (called *delta chains*).  
The resulting production for **A** becomes:  
`A → δ γ`  
(where **δ** represents one of **B**’s alternatives).

**Purpose:**  
After this step, the NT **A** will only contain, at most, **direct recursion** (if `A → A α` exists).

---

### 3. Elimination of Direct Left Recursion

Once the NT **A** is free of indirect left recursion, the standard transformation is applied to eliminate the **direct recursion**.

#### Partition:
The productions of **A** are divided into two groups:
- **Recursive alternatives** → productions of the form `A → A α`
- **Non-recursive alternatives** → called *beta chains*

#### Transformation:
A new Non-Terminal (**Z**) is introduced, automatically generated by the program.

The original NT **A** is redefined to use the *beta chains* followed by the new NT **Z**:

## REFERENCES

- **Aho, Alfred V. et al.** (2006). *Compilers: Principles, Techniques, and Tools (2nd Edition).* Addison-Wesley Longman Publishing Co., Inc. **(Section 4.3.3: Elimination of Left Recursion)**
These equivalent pairs are then printed as the output.

